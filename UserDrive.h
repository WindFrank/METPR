/*
    UserDrive: The user interface to drive the whole funciton in system.
*/

#pragma once

#include "Generator/Builder.h"
#include "Generator/Constructor.h"
#include "Arch.h"
#include "EDAExecuter/VTRDrive.h"
#include "MRVerify/MRManager.h"
#include "ActionMutateLead/Evaluate.h"
#include "ActionMutateLead/VarietyEvaluation.h"

#include <string>

using namespace std;

class UserDrive{
private:
    //The max width of each variable in HDL program.
    int varMaxW = 10;
    //Recent program set.
    string programSetPath = "";
    //Arch class and path
    Arch* arch;
    string archPath;
    //static adjust parameters. If set, auto increment will be executed.
    int staticAdjustIOs = 0;
    int staticAdjustStates = 0;
    //The type of verilog program generated
    string generateType = "";
    /*
    Init the content of a new HDL program set.
    setPath: The path and name of the target program set.
    */
    bool initHDLSetContent(string setPath);

    /*
    Generate initial program.
    setName: The name of the program set.
    setPath: The path and name of the target program set.
    num: The number of init program.
    stateIter: The number of statements in each initial program. 
               The higher the stateIter is, the larger the program is.
    varMaxW: The max width of each variable in HDL program.
    */
    bool generateHDLinitSet(string setName, string setPath, int num, bool activeCheck, int stateIter, int varMaxW, string sdc_type);

    /*
    Used to generate a single program.
    */
    string generateAProgram(string programName, int stateIter, int varMaxW);
public:
    UserDrive();

    /*
    Load program set by generating new HDL data.

    num: The number of the whole programs need generating.
    stateIter: The number of statements in each initial program. 
               The higher the stateIter is, the larger the program is.
    setPathName: The path and name of the target program set.
             If the set is existing, its structure, the necessary content in it, will be checked.
             If valid, the path of the set will be saved directly.
             It is recommended to use at least one level content to save all various HDL set.
    writeType: if conserve the origin programs. If set "overlap", only new programs will be saved.
    varMaxW: The max width of each variable in HDL program.
    deepLevel: The times of turns the larger HDL generated.
    conRatio: New percentage of the number of each new HDL generated to whole program.
    activeCheck: Use iverilog to do the active check for all verilog programs generated.
    */
    bool loadHDLSet(int num, int stateIter, string setPathName, string sdc_type="VTR", string writeType="none", 
                    int varMaxW=10, int deepLevel=2, double conRatio=0.5, bool activeCheck=false);

    /*
    Load Arch infomation.

    archPath: the path of Arch file.
    */
    bool loadArchPath(string archPath){
        int bound = archPath.rfind('/');
        string archName = "";
        if(bound == string::npos){
            archName = archPath;
        }
        else{
            archName = archPath.substr(bound + 1, archPath.size() - bound - 1);
        }
        arch = new Arch(archName, archPath);
        this->archPath = archPath;
        return true;
    }

    /*
    Run testing on VTR
    vtrPath: the root content of vtr
    treeHDLPath: the path of program set.
                 You need to locate the path to the concrete dir whose content is all valid programs.
    MRs: the list of MRs to used.
    turns: the times of testing turn.
    */
    bool VTRrunTesting(string vtrPath, string treeHDLPath, vector<string> MRs, int turns=1000, string diverV="False");

    /*
    Extract features from MR products.
    treeHDLPath: the path of program set, which contains structure generated by XXTesting.
                 You must load in a program set having tested.
                 If you want to extract features in several sets, you could combine them, or run them respectively.
    judgeBound: if distance > judgeBound, the data is seen as abnormal one. Default 3.
    if_remove_high_leverage: if open the high leverage point check and remove them before redusial analysis. Defaul true.
    testAnalysis: if set true, the function will automatically use feature.csv in project root content to do testing.
    
    Note: the long wire will be confirmed by the size of Arch. Specifically, the half of the average values of length and width.
    */
    bool VTRFeatureExtract(string treeHDLPath, vector<string> MRs, int judgeBound=3, bool if_remove_high_leverage=true, bool testAnalysis=false, string extractFeature="");

    /*
    Arrange: put all important data to target dir.
    Please run this method on your path where you run VTRTest
    treeHDL: target program set
    dataTypes: the data you want to arrange. If empty, all the data will be arrange.
               types: singleVerilogError Error_reports product Test setout DefectCases features performance
    */
    bool arrangeData(string treeHDLPath, string targetDir, vector<string> dataTypes={});
    
    /*
    Use VTR to simply run the assigned program set.
    treeHDLPath: the path of program set
    */
    bool VTRsimpleRun(string treeHDLPath, string archPath, string VTR_ROOT);

    /*
    Random run RTL two times (first run normally, second shuffle the order of blocks)
    compare their delay, wire length and slack.
    */
    bool VTRRTLRandomPerformTest(string treeHDLPath, string dataDir, string output, int turns, int seed);

    /*
    get performance data from random performance test
    */
    bool GetPerformData(string randomTestPath);

    /*
    get features of cases in ramdon test csv
    */
    bool VTRCaseSizeGet(string randomTestPath, string csv);

    /*
    Set the parameter of staticAdjustIOs and staticAdjustStates
    If set, the increment operation won't be executed.
    */
    bool adjustSet(int adjustIOs, int adjustStates){
        staticAdjustIOs = adjustIOs;
        staticAdjustStates = adjustStates;
        return true;
    }

    /*
    Set generate type: if choose "VTR", the program generated will not contain negedge, === and !==
    */
    bool setGenerateType(string type){
        generateType = type;
        return true;
    }
};